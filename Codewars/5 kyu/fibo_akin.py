# Последовательность u[1] = 1, u[2] = 1, u[3] = 2, u[4] = 3, u[5] = 3, u[6] = 4

# Как вычислить u[n]?
#   u[n-1] = x1, u[n-2] = x2;
#   u[n-x1] = y1, u[n-x2] = y2;
#   => u[n] = y1+y2 = u[n-x1]+u[n-x2] = u[n-u[n-1]]+u[n-u[n-2]]

# Задача:
# 1. Реализовать функцию u(n), вычисляющую n-тый элемент последовательности.
# 2. Реализовать функцию length_sup_u_k(n, k), вычисляющую количество элементов последовательности от 1 до n,
#    значение которых не меньше k.
# 3. Реализовать функцию comp(n), вычисляющую количество элементов последовательности от 1 до n,
#    чьё значение меньше значения предыдущего элемента

# Примеры:
#   u(900) => 455 (not tested)
#   u(90000) => 44337 (not tested)
#
#   length_sup_u_k(23, 12) => 4
#   length_sup_u_k(50, 10) => 35
#   length_sup_u_k(500, 100) => 304
#
#   comp(23) => 1 (since only u(16) < u(15))
#   comp(100) => 22
#   comp(200) => 63


# Лучше реализовать класс и три функции на основе нового класса.
# Но для простоты используем один список в глобальном нейм-спейсе.
u_sequence = [1, 1]


# Функция, вычисляющая 'num'-тый элемент последовательности.
def u(num):
    # Берём из глобального нейм-спейса наш список.
    global u_sequence

    # Если в нём нет нужного элемента то просто досчитаем до нужного элемента.
    if len(u_sequence) <= num - 1:
        for number in range(len(u_sequence) + 1, num + 1):
            u_num = u_sequence[number - 1 - (u_sequence[number - 2])] + u_sequence[
                number - 1 - (u_sequence[number - 3])]
            u_sequence.append(u_num)
        return u_sequence[num - 1]


# Функция, вычисляющая кол-во элементов последовательности от 1 до n,
#   чьё значение не меньше k.
def length_sup_u_k(n, k):
    global u_sequence

    # Обновим наш список элементов последовательности, если его не хватает.
    if len(u_sequence) <= n - 1: u(n)
    # Объявим переменную - будущий ответ.
    ans = 0
    # Пройдём по списку и посчитаем количество элементов, чьё значение не меньше k.
    for number in u_sequence[0:n]:
        if number >= k:
            ans += 1

    return ans


# Функция, вычисляющая кол-во элементов последовательности, чьё значение меньше, чем
#   значение предыдущего элемента последовательности.
def comp(n):
    global u_sequence

    # Обновим наш список элементов последовательности, если его не хватает.
    if len(u_sequence) <= n - 1: u(n)
    # Объявим переменную - будущий ответ.
    ans = 0
    # Пройдём по списку и посчитаем количество элементов, чьё значение меньше
    #   значения предыдущего элемента.
    for number in range(1, n):
        if u_sequence[number] < u_sequence[number - 1]:
            ans += 1

    return ans