# После работы Оля и Толя решили вместе сходить в тир.
# После прохождения вводного инструктажа и получения оружия они оказались на позициях для стрельбы,
# а напротив них находятся n мишеней.
# Все мишени можно считать фигурами, нанесёнными на бесконечную плоскость,
# при этом каждая мишень является кругом или прямоугольником,
# мишени могут накладываться и пересекаться произвольным образом.
# Перед тем как начать стрельбу, Оля и Толя хотят убедиться,
# что они смогут однозначно идентифицировать результаты своих выстрелов.
# Для этого они договорились провести прямую, которая поделит плоскость с мишенями на две части.
# Однако, чтобы никому не было обидно, они хотят провести прямую таким образом,
# чтобы каждая мишень была поделена ровно пополам,
# то есть для каждого круга и каждого прямоугольника должно быть верно,
# что прямая делит его на две фигуры равной площади.
#
# Когда Оля и Толя наконец закончили прорабатывать все условия разделения мишеней на две части,
# они начали сомневаться, что провести такую прямую вообще возможно, и просят вас ответить на этот вопрос.
#
# Формат ввода:
# В первой строке входных данных записано целое число n (1 ≤ n ≤ 100 000) — количество мишеней.
# Каждая из последующих n строк содержит целое число ti (0 ≤ ti ≤ 1), обозначающее тип мишени.
# Если ti = 0, то мишень является кругом и далее следуют три целых числа
# ri, xi, yi, определяющие радиус и координаты центра круга соответственно
# (1 ≤ ri ≤ 1000, -10 000 ≤ xi, yi ≤ 10 000)
# Если же ti = 1, то мишень является прямоугольником, который затем определяют восемь целых чисел
# x1i, y1i, x2i, y2i, x3i, y3i, x4i, y4i — координаты всех четырёх вершин
# (-10 000 ≤ xji, yji ≤ 10 000), перечисленных в порядке обхода по часовой стрелке или против часовой стрелки.
# Гарантируется, что данные четыре вершины образуют прямоугольник ненулевой площади.

# Формат вывода:
# Если существует прямая, которая поделит каждый из имеющихся кругов и прямоугольников
# на две части одинаковой площади, выведите “Yes”.
# В противном случае выведите “No”.

# Считываем количество фигур.
n = int(input())
n_counter = 0
# Создаём список для координат центров фигур.
centre_lst = []
# Заносим фигуры в список.
while len(centre_lst) != 2 and n_counter != n:
    figure_lst = [int(i) for i in input().split()]
    n_counter += 1
    # Если фигура - круг, то координаты уже есть.
    if figure_lst[0] == 0:
        if [figure_lst[2]*2, figure_lst[3]*2] not in centre_lst:
            centre_lst.append([figure_lst[2]*2, figure_lst[3]*2])
    # Если фигура - прямоугольник, то берём попарные суммы координат противоположных точек
    #   (противоположные точки прямоугольника - точки, не имеющие общей грани)
    #   и делим их пополам.
    else:
        if [(figure_lst[1]+figure_lst[5]), (figure_lst[2]+figure_lst[6])] not in centre_lst:
            centre_lst.append([(figure_lst[1]+figure_lst[5]), (figure_lst[2]+figure_lst[6])])

# TODO... В принципе можно сэкономить память, убрав полностью список centre_lst.
if n_counter == n:
    print("Yes")
else:
    # Возьмём координаты двух любых точек (в данном случае - первых двух в списке)
    x1 = centre_lst[0][0]
    y1 = centre_lst[0][1]
    x2 = centre_lst[1][0]
    y2 = centre_lst[1][1]
    # Теперь переберём все координаты центров фигур, если хоть одна не совпадёт, то выведем False.
    # Иначе выведем True.
    flag = True
    for figure in range(n-n_counter):
        figure_lst = [int(i) for i in input().split()]
        if figure_lst[0] == 0:
            x, y = figure_lst[2] * 2, figure_lst[3] * 2
        else:
            x, y = (figure_lst[1] + figure_lst[5]), (figure_lst[2] + figure_lst[6])

        # Для проверки будем использовать свойство векторного произведения векторов:
        if (x - x1) / (x2 - x1) != (y - y1) / (y2 - y1):
            flag = False
            break

    # В зависимости от флага выведем ответ
    if flag:
        print("Yes")
    else:
        print("No")
