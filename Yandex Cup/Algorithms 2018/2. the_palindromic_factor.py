# Аркадий — большой фанат использования машинного обучения в любой задаче.
# Он верит в безграничную силу волшебства этой популярной молодой науки.
# Именно поэтому Аркадий постоянно постоянно придумывает всё новые и новые факторы,
# которые можно вычислить для различных объектов.
#
# Напомним, палиндромом называется строка, которая одинаково читается от начала к концу и от конца к началу.
# Для каждой строки в своей базе данных Аркадий хочет найти самую короткую её подстроку,
# состоящую хотя бы из двух символов и являющуюся палиндромом.
# Если таких подстрок несколько, Аркадий хочет выбрать лексикографически минимальную.
#
# Формат ввода:
# В единственной строке входных данных записана одна строка из базы Аркадия —
# непустая последовательность строчных букв английского алфавита.
# Длина строки составляет не менее 2 и не превосходит 200000 символов.
#
# Формат вывода:
# Выведите минимальную по длине подстроку строки из входных данных,
# состоящую хотя бы из двух символов и являющуюся палиндромом. Если такой подстроки нет, то выведите −1

# Функция, проверяющая строку на фактор палиндромности
def is_palindrome(eng_str):
    if eng_str == eng_str[::-1]:
        return True
    else:
        return False


# Считываем строку.
test_str = input()
# Создадим два списка для хранения палиндромных подстрок длины 2 и 3
# Заметим, что можно сэкономить память, обойдясь без списков, но так как условие позволяет использовать 512 МБ,
#   то это не нужно.
palindrome_lst_two = []
palindrome_lst_three = []
# Вычислим длину исходной строки единожды, чтобы не считать её каждый раз в цикле.
length = len(test_str)

# В цикле переберём все подстроки длины 2 и 3 и если они являются палиндромами, то внесём в список
for i in range(length):
    if is_palindrome(test_str[i:i+2]) and i < length-1:
        palindrome_lst_two.append(test_str[i:i+2])
    if is_palindrome(test_str[i:i+3]) and i < length-2:
        palindrome_lst_three.append(test_str[i:i+3])

# Выведем палиндром минимальной длины, если таких несколько, то выберем лексикографически минимальный.
if len(palindrome_lst_two) != 0:
    print(min(palindrome_lst_two))
elif len(palindrome_lst_three) != 0:
    print(min(palindrome_lst_three))
# Иначе выводим -1.
else:
    print(-1)

# Решение от Яндекса:
# Пусть существует какая-то подстрока, являющаяся палиндромом.
# Если мы уберём первый и последний символ палиндрома, оставшаяся строка тоже будет палиндромом.
# Будем повторять процесс до тех пор, пока не останется строка из двух или трёх букв (в зависимости от чётности).
#
# Подстрок длины два или три всегда линейное количество, и суммарная их длина также линейна,
# поэтому среди таких строк ответ можно выбрать наивным алгоритмом.
# Если же ни одна из подстрок такой длины не является палиндромом, то выведем -1.
